# Shabfood backend implemented in FastAPI and PostgreSQL

## Table of Contents
1. [How To Run](#how-to-run)
1. [Implementation](#implementation)
    1. [API](#api)
    1. [Authentication](#authentication)
    1. [Database](#database)
2. [Description of backend components](#description-of-backend-components)
    1. [model package](#model-package)
       1. [Handlers](#handlers)
       2. [Interfaces](#interfaces)
       3. [Exceptions](#exceptions)
       4. [Schema](#schema)
    2. [Utilities](#utilities)

---

## How To Run

1. Fork/Clone

    ```sh
    $ git clone https://sutgl.devopstools.ir/ce/analysisdesign_0001.1/students-teams/Group6/mvp/shabfood.git
    $ cd shabfood/backend
    ```

1. Install postgresql with configurations in `backend/db/database.json`

- or you can install postgres with docker image:
    
    ```sh
    $ docker run --name shabfood_db -p 5432:5432 -e POSTGRES_PASSWORD=123 -d postgres
    ```

3. Create and activate a virtual environment:

    - linux and mac:

    ```sh
    $ python3 -m venv venv && source venv/bin/activate
    ```
    - windows:

    ```powershell
    python3 -m venv venv && venv\Scripts\activate.bat
    ```

1. Install the requirements:

    ```sh
    (venv)$ pip3 install -r requirements.txt
    ```

1. Run the app:

    ```sh
    (venv)$ python3 main.py
    ```

1. Test at [http://localhost:8000/docs](http://localhost:8000/docs)

---

## Implementation

### API

the backend API is [FastAPI](fastapi.tiangolo.com) a modern, fast (high-performance), web framework for building APIs with Python 3.6+ based on standard Python type hints.

The key features are:

* **Fast**: Very high performance, on par with **NodeJS** and **Go** (thanks to Starlette and Pydantic).

* **Fast to code**: Increase the speed to develop features by about 200% to 300%. *
* **Fewer bugs**: Reduce about 40% of human (developer) induced errors. *
* **Intuitive**: Great editor support. <abbr title="also known as auto-complete, autocompletion, IntelliSense">Completion</abbr> everywhere. Less time debugging.
* **Easy**: Designed to be easy to use and learn. Less time reading docs.
* **Short**: Minimize code duplication. Multiple features from each parameter declaration. Fewer bugs.
* **Robust**: Get production-ready code. With automatic interactive documentation.
* **Standards-based**: Based on (and fully compatible with) the open standards for AP

FastAPI api functions are implemented in `main.py`, the details are [here](docs/api-documentaion.html).

### Authentication

the authentication method is JWT(Json Web Token), the payload of token is generated by entity identifier and type (like Customer, Restaurant, etc) and before creation. after user signed in, the front app puts the token as a bearer token in order to be authenticated. backend has a list of signed users, in case of replacing their token when a user sign twice. the default alive time for each token is 1 hour. the implementation is in `utils.py`.

### Database

database type is RDBMS. ER and tables are in [here](db/docs/README.md), the queries between backend and database for entities CRUD are implemented in `crud.py`. it creates the database with its schema by running queries in `schema.sql`.

## Description of backend components
1. ### model package
   1. #### [Handlers](model/handle)
      This package includes one file for each main entity of the system namely **food**, **order**, **restaurant**, **customer**, and **deliverer**. Each file consists of functions which are responsible to process their related requests routed from [main.py](main.py) functions.
      
      For each type of the entities mentioned above, the usual set of create, read, update, and delete (CRUD) requests are handled in the corresponding files. However, there may be some exceptions due to the logical desing of the system like the lack of delete facility for order objects making them unremovable in system's database after being created.

      Meanwhile, there are some more specific requests like the public ones (without any authentication process required) issued on getting the whole list of all system restaurants or getting one specific one by its ID which are addressed in [restaurant.py](model/handle/restaurant.py) file. The functionality of getting menu of each restaurant is another example which is handled in [food.py](model/handle/food.py) using a properly named function.

      The most sophisticated entity of the system is obviously the order which is somehow the core object in the system interacting with almost all the other defined entities of the system. The only probable exceptional entity to this rule is deliverer in the case where the restaurant decides to send the order itself without using our deliverer finding facility so in this case no deliverer engages with the prepared order. In addition to the usual CRUD, the file [order.py](model/handle/order.py) handles all other order-related requests in the system regardless of what type of user is mainly initiating that request.

      It is worth to describe the ordering process which is the most significant process being performed in the system regularly. The main steps being done during the lifetime of an order are as follows:
        1. First, the customer submits an order by selecting his/her desired available foods and the quantity of each one from the menu of a desired restaurant. The state of order is set to its initial value which is **RESTAURANT_PENDING**.
        2. Afterwards the details of the requested order is sent to the target restaurant's panel where its all recent new orders can be seen. Then restaurant can either refuse or accept the order where in the first case the order will be totally cancelled without any financial transaction being done.
        3. But if the restaurant accepts the suggested order, it is assumed that the restaurant is going to prepare the requested order for the customer and the order's state is changed to **RESTAURANT_ACCEPT** 
        4. When the food is ready, the restaurant can either decide to send the order to the customer by itself or use the option of system's deliverer-finder facility. In the former case, the order's status in our system is immediatel set as **DONE** and *the whole responsibility of delivering the order is subject to the restaurant*.
        5. In the latter case, though, the order's state is set to **DELIVERER_PENDING** and our system starts to find an idle deliverer to suggest him/her delivery of the order. The current initial algorithm to do so is random but it can be improved by better ideas like finding suggesting to the deliverers in an ascending order of their distance from the target restaurant. Currently the system suggests the order to a totally random, but of course idle, deliverer. The selected deliverer's state is changed to **ON_DECISION** and he/she. When he/she requests the server for his/her current probable suggested order, the suggested order's details are shown to him/her and so he/she may refuse or accept to carry the order.
            1. In the refusal case, the status of the order ramains unchanged and the system will search for another idle deliverer (this deliverer may also be picked again). 
            2. In the acceptance case, the order and deliverer are bundled to each other and their states are modified to **DELIVERING** and **BUSY**, respectively. So it is assumed that he/she is on the way from restaurant toward customer's location.
        6. Finally when the deliverer arrives at the customer's location and gives the order to him/her, the deliverer confirms the successful transfer of the order and so the state of the order is changed to **DONE**.
    2. #### [Interfaces](model/db_driver.py)
        This file includes the signature of the requierd interfaces which are implemented in the proper files inside handle folder according to their name and usage in the system.
    3. #### [Exceptions](model/exceptions.py)
        As its name implies, this file contains all our customly defined exceptions to handle any unnormal situation occurred in the system including sending proper error messages to the front-end, if needed.
    4. #### [Schema](model/schema.py)
        This file includes the definition of all runtime objects of the system mostly synchronized with their tables designed in the database with some probable necessary additions. It also contains some helpful functions to get different categories of order states based on different users of the system and also some other functions to get the set of valid transitions restaurant or deliverer are able to perform on the state of their assigned orders. For example, this set of limited valid transitions certify that the state of a cancelled or done order can never be changed anymore by any type of user.
2. ### [Utilities](utils.py)
    This file contains some auxiliary functions used broadly in the project's different parts for some stuff like validating regular expressions (REGEXs), checking input passwords' strength, etc.